% LaTeX Präsentationsvorlage (2013) der TU Graz, rev12, 2013/01/31
% !TeX encoding = UTF-8
\documentclass{beamer}
% \documentclass[aspectratio=169]{beamer}
% \usetheme{tugraz2013}
% \usetheme[notes]{tugraz2013}
\usepackage{../common/beamerthemetugraz2013}
\usepackage{color}
\usepackage{multicol}
\usepackage{bbding}
\usepackage{wasysym}
\usepackage{caption}
% \usepackage{minted}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\usepackage{picture}
\usepackage{rotating}

\definecolor{darkred}{rgb}{0.85,0.16,0.0}
\definecolor{darkgreen}{rgb}{0.16,0.70,0.27}

\newcommand{\hrefu}[2]{\underline{\href{#1}{#2}}}

\newcommand{\red}[1]{{\color{red} #1}}
\newcommand{\blue}[1]{{\color{blue} #1}}
\newcommand{\darkgreen}[1]{\textcolor{darkgreen}{#1}}
\newcommand{\darkred}[1]{\textcolor{darkred}{#1}}

\newcommand*{\vpointer}{\vcenter{\hbox{\scalebox{1.5}{\large\pointer}}}}

%% Titelblatt-Einstellungen
\title[]
{Python 04}
\author[E.~Wachmann]{\scriptsize Elias Wachmann
}
\date{2024} % \today für heutiges Datum verwenden
\institute[Institute of Theoretical and Computational Physics]
{
}
\instituteurl{www.tugraz.at}
% \institutelogo{kurz.pdf}
%~ \additionallogo{merged_logos}

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\titleframe


\begin{frame}
  \frametitle{Crash course is over...}
  So far we've learned: 
  \begin{itemize}
    \item How to setup Python \& VS-code
    \item \hrefu{https://numpy.org/}{numpy}, \hrefu{https://matplotlib.org/}{matplotlib}, random numbers and basic file I/O
    \item Functions, files and how to fit data
  \end{itemize}
  \vspace{5mm}
  Now we will start from the ground up with Python: 
  \begin{itemize}
    \item Data types \& operators
    \item Branching
    \item Loops ...
  \end{itemize}
\end{frame}

\section*{Content}

\begin{frame}
\frametitle{Content}
  \tableofcontents
\end{frame}

\section{Data types \& Operators}
\begin{frame}
    \frametitle{Primitive types}
    \begin{itemize}
      \item \texttt{int} for integers (1, 2, 3, ...)
      \item \texttt{float} for floating point numbers (1.0, 3.1415, ...)
      \item \texttt{double} for double precision floating point numbers \\
      (1.0, 3.1415, ...)
      \item \texttt{bool} for booleans (True, False)
      \item \texttt{str} for strings ('Hello', 'World', ...)
      \item \texttt{char} for characters ('a', 'b', ...)
      \item \texttt{None} for null values (None)
    \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{\hrefu{https://numpy.org/doc/stable/user/basics.types.html}{numpy - data types}}
  Non-exhaustive list of numpy data types:
  \begin{itemize}
    \item \texttt{int8, int16, int32, int64} for integers
    \item \texttt{uint8, uint16, uint32, uint64} for unsigned integers
    \item \texttt{float16, float32, float64, float128} for floating point numbers
    \item \texttt{complex64, complex128, complex256} for complex numbers
    \item \texttt{bool} for booleans
    \item \texttt{str} for strings
    \item \texttt{None} for null values
  \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Types}
  \begin{itemize}
    \item Python is dynamically typed
    \item Types are inferred from the value
    \item Types can be changed
    \begin{itemize}
      \item \texttt{a = 1}
      \item \texttt{a = 'a'}
    \end{itemize}
    \item Types can be checked with \texttt{type(a)}
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{Operators}
  \begin{itemize}
    \item Arithmetic operators
    \begin{itemize}
      \item + addition (x + y)
      \item - subtraction (x - y)
      \item * multiplication (x * y)
      \item / division (float) (x / y)
      \item // division (int) (x // y)
      \item ** exponentiation (x ** y)
      \item \% modulo (x \% y)
    \end{itemize}
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{Assignment Operators}
  \begin{itemize}
    \item Assignment operators
    \begin{itemize}
      \item = assigns a value to a variable (x = 5)
      \item += adds a value to a variable (x += 3 == x = x + 3)
      \item -= subtracts a value from a variable (x -= 3)
      \item *= multiplies a variable (x *= 3)
      \item /= divides a variable (x /= 3)
      \item ... and so on 
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Comparison Operators}
  \begin{itemize}
    \item Comparison operators
    \begin{itemize}
      \item == equal (x $\equiv$ y)
      \item != not equal (x $\neq$ y)
      \item \texttt{>} greater than (x $>$ y)
      \item \texttt{<} less than (x $<$ y)
      \item \texttt{>=} greater than or equal to (x $\geq$ y)
      \item \texttt{<=} less than or equal to (x $\leq$ y)
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Logical Operators}
  \begin{itemize}
    \item Logical operators
    \begin{itemize}
      \item \texttt{and} returns True if both statements are true \\(x \texttt{>} 3 \texttt{and} x \texttt{<} 10)
      \item \texttt{or} returns True if one of the statements is true \\(x \texttt{>} 3 \texttt{or} x \texttt{<} 4) 
      \item \texttt{not} returns False if the result is true \\(\texttt{not}(x \texttt{>} 3 \texttt{and} x \texttt{<} 10))
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Identity Operators}
  \begin{itemize}
    \item Identity operators
    \begin{itemize}
      \item \texttt{is} returns True if both variables are the same object \\(x \texttt{is} y)
      \item \texttt{is not} returns True if both variables are not the same object \\(x \texttt{is not} y)
    \end{itemize}
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{\textcolor{gray}{Bitwise operators}}
  \begin{itemize}
    \item \textcolor{gray}{Bitwise operators}
    \begin{itemize}
      \item \textcolor{gray}{\& AND (x \& y)}
      \item \textcolor{gray}{\texttt{|} OR (x \texttt{|} y)}
      \item \textcolor{gray}{\^ \, XOR (x \^ \, y)}
      \item \textcolor{gray}{\texttt{\~} NOT (\texttt{\~} x)}
      \item \textcolor{gray}{\texttt{<<} left shift (x \texttt{<<} 2)}
      \item \textcolor{gray}{\texttt{>>} right shift (x \texttt{>>} 2)}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Conversion to other types}
  \vspace*{-1cm}
  \begin{itemize}
    \item \texttt{int(x)} converts x to an integer
    \item \texttt{float(x)} converts x to a float
    \item \texttt{str(x)} converts x to a string
    \item \texttt{bool(x)} converts x to a boolean
    \item \texttt{list(x)} converts x to a list
    \item \texttt{tuple(x)} converts x to a tuple
    \item \textcolor{gray}{\texttt{set(x)} converts x to a set}
    \item \textcolor{gray}{\texttt{dict(x)} converts x to a dictionary}
    \item \textcolor{gray}{\texttt{complex(x)} converts x to a complex number}
    \item \textcolor{gray}{\texttt{bytes(x)} converts x to a bytes object}
    \item \textcolor{gray}{\texttt{bytearray(x)} converts x to a bytearray object}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Precision Issues in Floating Point Arithmetic}
  
  In many programming languages, especially those using floating point arithmetic, \textbf{0.1 + 0.1} might not always equal \textbf{0.2}.
  
  \begin{itemize}
    \item This is due to the inherent limitations of representing real numbers in binary format.
    \item Floating point numbers have limited precision, and some numbers cannot be represented exactly.
    \item Therefore, arithmetic operations involving floating point numbers may introduce rounding errors.
  \end{itemize}
\end{frame}
\begin{frame}
  \onslide{For example, in Python:}
  
  \begin{itemize}
    \item \texttt{>>> 0.1 + 0.1} yields \texttt{0.2} (as expected).
    \item However, \texttt{>>> 0.1 + 0.1 + 0.1} yields \texttt{0.30000000000000004}.
  \end{itemize}
  \onslide{Similar issues may occur in other programming languages.}
\end{frame}
  

\section{Lists \& Tuples}
\begin{frame}
\frametitle{Lists}
  \textbf{\hrefu{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{Lists}} are a collection of items that are \textbf{ordered} and \textbf{changeable}.\\
  \vspace{5mm}
  \textbf{Example:}
  \lstinputlisting[language=python, firstline=1, lastline=1]{examples/lists1.py}
  \vspace{5mm}
  \textbf{Note:} lists are \textbf{mutable} objects. Meaning that they can be changed after they have been created.
\end{frame}
\begin{frame}
\frametitle{Lists}
  \textbf{Example:}
  \lstinputlisting[language=python]{examples/lists1.py}
\end{frame}
\begin{frame}
  \frametitle{Tuples}
  \textbf{\hrefu{https://docs.python.org/3/tutorial/datastructures.html\#tuples-and-sequences}{Tuples}} are a collection of items that are \textbf{ordered} and \textbf{unchangeable}.\\
  \vspace{5mm}
  \textbf{Example:}
  \lstinputlisting[language=python, firstline=1, lastline=1]{examples/tuples1.py}
  \vspace{5mm}
  \textbf{Note:} tuples are \textbf{immutable} objects. Meaning that they can \textbf{not} be changed after they have been created.
\end{frame}
\begin{frame}
  \frametitle{Tuples}
  \textbf{Example:}
  \lstinputlisting[language=python]{examples/tuples1.py}
\end{frame}
\section{Branching}
\begin{frame}
  \frametitle{If, elif, else}
  \textbf{If, elif, else} statements are used to execute code depending on a condition.
  \begin{itemize}
    \item \texttt{if} is used to execute code if a condition is true.
    \item \texttt{elif} is used to execute code if a condition is true and the previous conditions were false.
    \item \texttt{else} is used to execute code if all previous conditions were false.
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{If, elif, else}
  \textbf{Caution:} \texttt{if}, \texttt{elif} and \texttt{else} statements must be indented. This way the python-interpreter knows which code belongs to the \texttt{if}, \texttt{elif} or \texttt{else} statement. 
  \lstinputlisting[language=python]{examples/if1.py}
\end{frame}
\begin{frame}

  \frametitle{Using If on lists or strings}
  You can use \texttt{if} statements on lists or strings with the \hrefu{https://www.w3schools.com/python/ref_keyword_in.asp}{\texttt{in}} / \hrefu{https://www.w3schools.com/python/ref_func_any.asp}{\texttt{any}} / \hrefu{https://www.w3schools.com/python/ref_func_all.asp}{\texttt{all}} operator.
  \lstinputlisting[language=python]{examples/if2.py}
\end{frame}
\begin{frame}
  \frametitle{If with multiple conditions}
  You can use \hrefu{https://www.w3schools.com/python/python_operators.asp}{\texttt{and} \& \texttt{or}} to combine multiple conditions.
  \lstinputlisting[language=python]{examples/if3.py}
  The \hrefu{https://www.w3schools.com/python/ref_keyword_not.asp}{\texttt{not}} keyword is used to invert the result of a condition.
\end{frame}
\begin{frame}
  \frametitle{Ordering of conditions}
  \lstinputlisting[language=python, lastline=7]{examples/if4.py}
  \vspace{5mm}
  What is the output of this script?
\end{frame}
\begin{frame}
  \frametitle{Ordering of conditions}
  \lstinputlisting[language=python, firstline=10]{examples/if4.py}
  \vspace{5mm}
  \texttt{x is positive} will be printed.
\end{frame}

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% EOF
